---
updateTime: '2025-12-21 18:26'
tags: Java
---
这里假设是对商品库存的秒杀
瓶颈：mysql 2C+4g 500qps ?
# 问题描述
- 对单行更新需要经过开启事务->拿锁->写undo->写redo->写binlog->提交事务->释放锁
- 所有请求都**按顺序执行这一系列操作**，一直占用着数据库连接

关键要点：不要让所有流量都去**竞争一个行级锁**

# 方案一
- 把库存放到redis,由redis去做库存扣减
- 同步/异步创建订单
> **问题:**
> - 如果redis扣减库存失败(**超时，但是实际扣减成功**)
>
>   可以在redis扣减时，也记录流水，反查一下流水，看是否成功
> -  redis库存和mysql库存**同步问题**
>
>   
>    可以使用定时任务/mq的方式同步回mysql，但是最后都需要拉流水出来对比
> - 如果异步创建订单，会有丢失消息/消息堆积的风险
> - 如果同步创建订单，mysql创建订单失败，如何回滚redis库存？
>     - 如果用定时任务的方式去同步mysql的库存？库存扣减成功，但是mysql扣减失败，但是**定时任务触发了库存同步**，导致数据不一致？
# 方案二
- 对mysql的库存行进行拆分，根据用户的请求，路由到不同的数据行
> 问题：
> - 如果**路由倾斜**，可能会出现**大量商品少卖**
>
>   
>   **本地缓存记录**该行是否还有库存，如果没有，顺序找下一个
# 方案三
- 使用hint，利用一些云数据库本身提供的hint方案
  ```sql
  UPDATE /*+ COMMIT_ON_SUCCESS ROLLBACK_ON_FAIL TARGET_AFFECT_ROW(1) */ inventory 
  SET count = count - 1 
  WHERE id = 100;
  ```
- COMMIT_ON_SUCCESS：执行成功立即提交事务。

- ROLLBACK_ON_FAIL：执行失败回滚事务。

- TARGET_AFFECT_ROW：验证影响行数，防止误操作。
> **原理：**
> 1. 分组合并与并行执行
>    - 分组机制：识别带有COMMIT_ON_SUCCESS等Hint的SQL，**按主键或唯一键分组**，将同一行的更新操作合并处理。
>    - **双执行单元**：采用两个执行单元交替工作，一组提交时另一组开始收集新请求，实现并行处理，提升吞吐量。
> 2. 关键优化点
>    -  **减少锁竞争**：
>   
>      
>        同一组的更新操作中，仅第一条（Leader）需竞争行锁，后续操作（Follower）复用锁，避免锁等待。
>    - 减少B+树遍历：
>   
>       每组首次执行时通过索引定位数据行并缓存至Row Cache，后续操作直接修改缓存，减少索引遍历开销。
>    - **组提交事务**：
>
>      将多个事务合并为一次提交，降低日志刷盘和锁释放的频率，减少事务开销。

# 方案四

把秒杀**拆分为两个接口**

 - 先到预扣减接口：风控、资格校验、扣减redis(120%库存)、返回token
 - 用户带着token来真正下单
> 如果实在怕mysql抗不住，可以维护一个zset做滑动窗口(key为token,score为时间戳),一个窗口内只允许多少个请求，如果超过了，**把token的状态设置为需重试**
> 
> **优点**：如果mysql扣减失败，用户可以带着token到第二个接口重试
> 
> **缺点**：redis把qps和数据库的峰值拉平了
