
## TT
**1、介绍项目流程**
下单流程：
拉回订单、拆单、落到渠道表、定时捞出来转换生单、成功后发条消息(校验监听)、订单hold住，做校验（责任链风控）、第三方平台确认、推送到ERP、创建包裹
校验：地址校验、包裹二次校验、金额校验、黑名单、欺诈检测
用户风控标签(画像，等级)
调拨流程：
内部再wms发起

**2、为什么要做数据迁移？怎么做？**
之前的同步逻辑再ERP、再同步到OMS、再放同步到ERP
现在把数据放到，做新的需求，订单转换逻辑更复杂：比如要根据productId创建商品链接
双写、校验几次、低峰期把存量拉过来、校验、切流

**3、多渠道的订单数据异构，怎么做？**
落到渠道订单表，再解析Json

**4、渠道订单异构，如何单独做推送处理？**
数据库配置规则Json规则{"channel":"OZON","needPullFaceOrder":true}，对应一个Handler。Handler命中之后，判断时候满足，如果这个订单不满足这个规则

**5、规则引擎和责任链的区别**

6、为什么要使用MQ做分布式事务？怎么保证一致性，有什么有缺点？
默认后序的操作一定会成功(最终一致)
解耦系统，异步处理，提高吞吐量。
实现最终一致性，避免同步阻塞

**7、MQ消费熔断？**

死信队列：多次失败后转入死信队列

**8、消息积压如何处理？顺序消息积压如何如何？**

消息积压：一般消费失败会无限重试，可以让他返回ack,再投递到另一个topic（类似死信）

**9、消息如何保证幂等？**

**10、MQ消费失败的退避策略？TCP退避策略**

**11、什么是时候会发生重平衡？重平衡后如何分配哪个消费者消费哪个partition？由谁负责平衡？**

**12、有什么路由算法？hash和一致性hash区别？**

**13、介绍一下项目遇到的死锁？insert和update一起会导致死锁么？为什么会OOM？**

diff先判断时候要update和insert，全量和增量的顺序

但是需要注意间隙锁

**14、RPC和HTTP区别？属于哪一层？为什么又rpc(gRPC)是基于http来做? 为什么二进制比文本快**

复用http的功能: URL路由、参数传递、错误处理（重定向、缓存控制）、安全机制

hessian序列化、Json序列化、ProtoBuf

算法：判断一棵树时候是另一颗树的子树
```java
public boolean judge(Node node1 ,Node node2){
  if(node1==null && node2==null){
    return true;
  }
  if(node1.val!=node2.val)retuen false;
  return judge(node1.left,node2.left)&&judge(node1.right,node2.right);
  
}
```
### 二面
所有子数组最小值的和
双单调栈
```java
最小子数组和
一个数组记录左边第一个比我小的元素的位置（单调递增栈）
一个数组记录右边第一个比我小的元素的位置
收集答案：(以当前值为最小值的子数组有这么多个)
以当前值为最小值的区间为：区间左端点可以在i-left[i]个数里选一个，区间右端点可以在right[i]-i个数里选一个
 ans += (long) (i-left[i])* (right[i]-i) * arr[i];

 public int sumSubarrayMins(int[] arr) {
    int n = arr.length;
    int[] left = new int[n];
    int[] right = new int[n];
    Deque<Integer> stack = new ArrayDeque<>();
    final int MOD = 1000000007;

    // 找左边第一个≤当前值的元素
    for (int i = 0; i < n; i++) {
        while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {
            stack.pop();
        }
        left[i] = stack.isEmpty() ? -1 : stack.peek();
        stack.push(i);
    }

    stack.clear();

    // 找右边第一个<当前值的元素
    for (int i = n - 1; i >= 0; i--) {
        while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {
            stack.pop();
        }
        right[i] = stack.isEmpty() ? n : stack.peek();
        stack.push(i);
    }

    long ans = 0;
    for (int i = 0; i < n; i++) {
        ans += (long) (i - left[i]) * (right[i] - i) * arr[i];
        ans %= MOD;
    }
    return (int) ans;
}
 ```
二叉搜索树删除一个节点
```java

pubilc Node delete(Node node,Node target){
  if(node<target){
    node.right=delete(node.right);
  }else if(node>target){
    node.left=delete(node.left);
  }else{
    if(node.left==null && node.right==null)return null;//删除当前节点
    if(node.left==null)return node.right;
    if(node.right==null)return node.left;
    //左右子树都不为空，找到右子树最小的节点，覆盖当前节点
    Node min=findMid(node.right).val;
    node.val =min.val;
    //把刚刚找到的节点删掉
    node.right=delete(node.right,min);
  }
  return node;
}
findMin(Node node){
  while(node!=null && node.left!=null){
    node=node.left;
  }
  return nodel
}
```