---
updateTime: '2025-12-21 18:26'
tags: 算法
---
for循环的长度为数的第一层节点数
# 模板
```java
if(){
  ans.add(new ArraryList<>(path));
}
for(int i=0;i<len;i++){
  path.add();
  backTrack();
  path.removeLast();
}
```

## 笛卡尔积
```java
//待搜索的数组是二维数组[[a,b],[c,d]] -> [[a,c], [a,d], [b,c], [b,d]]
//思路：拿了a -> 再拿c,再拿d
遍历的时候要遍历到深层的位置
for(int n : array[index])
//终止条件：index==aray.length 收集答案
```
## 组合总和
```java
//[1,2,3,4,5] 搜索到 和为5 的所有组合
for(int i=index;i<array.size();i++){
    share.add(array.get(i));
    back(sum+array.get(i),i);//下回又从i开始查找（允许重复）
    remove
}

//不允许有重复
array.sort()
for(int i=index;i<array.size();i++){
    if(i>index && array[i]==array[i-1])continue;
    share.add(array.get(i));
    back(sum+array.get(i),i+1);//下回又从i开始查找（允许重复）
    remove
}


```
## 排列
```java
//搜索长度为n的所有排列
// [1,2,3,4,5]=>[1,2,3] [3,2,1]
boolean[] visisted=new bollean[5];
for(int i=0;i<n;i++){
    if(visisted[i])continue;
    visisted[i]=true;
    share.add(a[i]);
    back();
    visisted[i]=false;
    remove
    
}
//不允许有重复 [1,1,2] 不能有[2,1(0),1(1)] [2,1(1),1(0)]
boolean[] visisted=new bollean[5];
Arrays.sort(nums);
for(int i=0;i<n;i++){
    if(visisted[i])continue;
    if(i>0 && !vistit[i-1] && nums[i]==nums[i-1]){//排除第二种情况
        continue;
    }
    visisted[i]=true;
    share.add(a[i]);
    back();
    visisted[i]=false;
    remove
    
}
```
## 括号生成
```java
终止条件：左括号数目大于n || 右括号数目大于左括号
        右括号==n时，收集答案
dfs(int leftNum,int rightNum){
    if(leftNum>n || rightNum>leftNum)return;//停止往下搜素(放东西进path)
    if(share.size()==n*2){add();return}
    
    share.append("(");
    dfs(l+1,r);//往下搜索
    share.deleteCharAt(size-1);
    //搜索右括号
    share.append(")");
    dfs(l,r+1);
    share.deleteCharAt(size-1);
}
```
## ip地址复原
```java

收集答案
if(begin==len){//如果不加，会出现后面 有数字漏掉的情况
    if(split==4){
      ans.add(String.join(".",path.stream().map(String::valueOf).toList()));
    }
    return;
}
停止往下搜素情况   
//4-split代表 还需要 这么多个ip段
len-begin < 1*(4-split)//剩下的数字 连 每个ip段是1位都不能满足
len-beign > 3*(4-split)//剩下的数字 会有ip段大于3位

for(int i=0;i<3;i++){//第一层有3种可能(不超过3个数字)
    if(begin+i>=len)return;
    f=judge(begin,begin+i)//放入path之前要校验ip段(长度大于1不能0开头，不能>255 )
    if(f!=-1){
        path.add(f);
        back(begin+i+1,split+1)
        path.removeLast();
    }
}

```

## 分割回文串
```java
public void dfs(nums,begin){
    if(begin==len){ans.add();}
    for(int i=begin;i<len;i++){
        //if(begin+i>=len)return;
        if(judge(substring(begin,i+1))){
            path.add(substring);
            dfs(nums,i+1);
            remove
        }
        
    }
}
```

## N皇后
```java
按行放棋子
//行，列，主，副对角线不能冲突
如何表示当前主、副对角线(长度为2*n-1)
主对角线：row-col+n-1为固定值//加上n-1主要是映射一下(不能负数)
副对角线：row+col为固定值
public void dfs(int row){
        if(row==n){
            for(int i=0;i<n;i++){
                StringBuilder sb=new StringBuilder(".");
                for(int j=0;j<n-1;j++){sb.append('.');}
                sb.setCharAt(path[i],'Q');
                p.add(sb.toString());
            }
            ans.add(new ArrayList<>(p)); 
            p=new ArrayList<>();             
            return;
        }
        for(int col=0;col<n;col++){//每行的每一列
            if(!visit1[row+col] && !visit2[row-col+n-1] && !colVisit[col] ){
                path[row]=col;//放棋子
                visit1[row+col]=true;
                visit2[row-col+n-1]=true;
                colVisit[col]=true;
                dfs(row+1);//下一行
                path[row]=-1;
                visit1[row+col]=false;
                visit2[row-col+n-1]=false;
                colVisit[col]=false;
            }
        }
    }

```
