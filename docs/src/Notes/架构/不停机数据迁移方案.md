---
updateTime: '2025-12-21 18:26'
tags: 架构
---
> 这里只讨论**不停机数据迁移**
# **难点分析：**
- **并发问题**
  - 在做**存量数据**迁移的时候会有请求**并发去修改旧表**
- 数据量大，**中间断了**
  - 在数据里加一个字段\或者利用现有的字段记录进度
  - 借助redis记录进度
- 数据MQ同步**顺序问题**
  - 消费者更新比较版本号
  - 生产者携带preID
- **消息丢失/转换错误**
  - 增量校验
  - 全量校验
- **灰度**哪些用户的数据据
## 方案一
- 借助第三方 数据迁移工具DTS
- 可以基于**cannal的adapter**执行全量迁移curl -X POST http://127.0.0.1:8081/etl/es7(rdb、hbase)/sys_user.yml

  
先启动增量，随后全量，**全量会阻塞增量**。
## 方案二
分为**增量同步**和**全量同步**

- 增量双写
  - FinkCDC
  - canal
  - 自己发送MQ
> 因为要保证**可灰度、监控、止血**
> 
> 这里需要**增量双写**（旧表也要写），如果数据同步失败可根据**开关快速止血**
> 
> 但是写新表应该在异步链路上，**旧表必须写成功**

**注意**：启动全量之前要把增量数据拉出来校验一把

- 全量(存量)
> 并发问题：
> 
> 问题：全量任务扫到了当前数据A在内存里了(新表还没插入)，用户后改了A，准备去updata,发现新表没有，跳过了这次update
> - 假设以**用户维度**作为灰度选择（建一张灰度表/bitmap/set）命中**锁住**当前用户操作,等到当前用户的**所有数据迁移完毕后**，释放锁
> - **不锁**用户的操作，锁住当前的全量任务ID，让增量update必须等**当前批次** 的全量先执行完
> - 双写 即使是更新的也**把一整条数据同步过去**，如果没有这条记录就做insert，如果后续的insert冲突了，说明之前的双写过了，改为update（注意这里要加**版本号**，避免更新丢失）
>
**注意**：全量之后要把数据拉出来校验一把
- 双写读新表
  > 这里也可以用灰度的方案
- 读新表，写新表
  > 这时候应该要保证新库必须写成功
> 如果要保证**双写都成功**可以使用本地消息表的方式保证在同一个事务里面
```java
public class ProducerBean implements DisposableBean, InitializingBean, ApplicationContextAware {
    private static final Logger logger = LoggerFactory.getLogger(ProducerBean.class);
    private static ApplicationContext context;
    private static final String APP_NAME_SUFFIX = "_PRE";
    private boolean isProgrammingTxModel;
    private boolean hasCustomTransactionManager = false;
    private DataSourceTransactionManager customTransactionManager;
    private TransactionTemplate transactionTemplate;
    private Producer producer;
    // 本地消息表，主要配置这个这个属性
    private TxMessageDao txMessageDao;
    private String topic;
    private String lookupAddresses;
    private int connectionTimeout = 500;
    private int threadPoolSize4IO = 4;
    private int queryTimeoutInMillisecond = 3000;
    private int connectionSize = 30;
    private boolean useTx = false;
    private String appName;
    private boolean compressed = false;
    private String zkConnection = null;
    private int pubRetry = 3;

    public ProducerBean() {
        if (TxUtils.isCurrentPreEnv()) {
            this.appName = System.getProperty("application.name") + "_PRE";
        } else {
            this.appName = System.getProperty("application.name");
        }

    }

    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        context = applicationContext;
        if (Objects.nonNull(this.customTransactionManager)) {
            this.hasCustomTransactionManager = true;
            logger.info("setup tx produce bean with local transaction manager {}", this.customTransactionManager);
        } else {
            try {
                this.hasCustomTransactionManager = this.isBeanExist(DataSourceTransactionManager.class);
            } catch (NoSuchBeanDefinitionException var4) {
                logger.info("You have not set up the com.youzan.platform.tx.DataSourceTransactionManager!", this.topic);
            }
        }

        if (Objects.nonNull(this.transactionTemplate)) {
            this.isProgrammingTxModel = true;
            logger.info("setup programming tx mode with local transaction template {}", this.transactionTemplate);
        } else {
            try {
                this.isProgrammingTxModel = this.isBeanExist(TransactionTemplate.class);
            } catch (NoSuchBeanDefinitionException ne) {
                logger.info("Failed to find the bean TransactionTemplate!", ne);
            }
        }

    }

    private <T> boolean isBeanExist(Class<T> c) throws NoSuchBeanDefinitionException {
        return context.getBeansOfType(c).size() > 0;
    }

    public void afterPropertiesSet() throws Exception {
        NSQConfig config = new NSQConfig();
        if (StringUtils.isBlank(this.lookupAddresses)) {
            throw new RuntimeException("Nsq provider must need lookupAddresses, please config it");
        } else {
            config.setLookupAddresses(this.lookupAddresses);
            config.setConnectTimeoutInMillisecond(this.connectionTimeout);
            config.setThreadPoolSize4IO(this.threadPoolSize4IO);
            config.setQueryTimeoutInMillisecond(this.queryTimeoutInMillisecond);
            config.setConnectionPoolSize(this.connectionSize);
            config.setPublishRetry(this.pubRetry);
            this.producer = new ProducerImplV2(config);

            try {
                this.producer.start();
            } catch (Exception e) {
                logger.error("Nsq producer topic[{}] start exception:", this.topic, e);
                return;
            }

            logger.info("Nsq producer topic[{}] start success.", this.topic);
        }
    }


    public boolean sendTx(Object msg) {
        return this.sendTx(this.topic, msg);
    }
  //主要在这里插入本地消息表
    public boolean sendTx(String dynamicTopic, Object msg) {
        if (!this.hasCustomTransactionManager) {
            throw new IllegalStateException("You haven't config com.youzan.platform.tx.DataSourceTransactionManager, please config it!");
        } else {
            if (!this.isProgrammingTxModel) {
                try {
                    TransactionAspectSupport.currentTransactionStatus();
                } catch (NoTransactionException e) {
                    throw new IllegalStateException("You haven't set @Transactional annotation, please set it!", e);
                }
            }

            int lastShardId = this.txMessageDao.selectLastShardId();
            // "insert into tx_message (`create_at`, `update_at`, `app_name`, `msg_body`, `topic`, `extra`, `version`, `sharding_id`, `compressed`) VALUES (now(), now(), ?, ?, ?, ?, ?, ?, ?)";

            int res = this.txMessageDao.insert(TxUtils.buildTxMessage(msg, this.appName, dynamicTopic, lastShardId));
            long pk = 0L;

            try {
                pk = this.txMessageDao.selectLastId();
                TxContext.getContext(this.getTxMessageDao().getDataSource()).setTxProperties(this.producer, this.txMessageDao, this.getBytesFromMessage(msg), dynamicTopic, lastShardId, pk);
            } catch (Exception e) {
                logger.error("TxMessage put threadLocal fail topic[{}], lastShardId[{}], pk[{}]: {}", new Object[]{dynamicTopic, lastShardId, pk, e});
            }

            return res == 1;
        }
    }

    public void sendFailure(String topic, String msgBody, int shardingId, long pk) {
        try {
            this.producer.publish(msgBody.getBytes("utf-8"), topic);
            this.txMessageDao.delete(pk, shardingId);
        } catch (Exception e) {
            logger.error("Scan TxMessage and Send fail topic[{}]: {}", new Object[]{topic, msgBody, e});
        }

    }

    private byte[] getBytesFromMessage(Object msg) throws UnsupportedEncodingException {
        try {
            String msgJson = StringUtils.toJsonString(msg);
            return msgJson.getBytes("utf-8");
        } catch (Throwable t) {
            logger.error("getBtye form message failed: ", t);
            throw t;
        }
    }

    public void destroy() throws Exception {
        if (this.producer != null) {
            this.producer.close();
        }

    }
}

```
> 定时任务扫表
```java
// TxMessageScan.class
private int scanSingleShard(int shardingId) {
  //查出当前分片消息
        List<TxMessage> txMessageList = this.txMessageDao.queryByShardingId(shardingId, this.nsqProducerBean.getAppName());
        if (CollectionUtils.isEmpty(txMessageList)) {
            return 0;
        } else {
            for(TxMessage txMessage : txMessageList) {
                if (ServiceChainContext.getCurrentServiceChainName() == null || !StringUtils.isEmpty(txMessage.getExtra())) {
                    String env = StringUtils.isEmpty(txMessage.getExtra()) ? null : TxUtils.parseExtra(txMessage.getExtra()).getEnv();
                    if ((!TxUtils.isPreEnv(env) || TxUtils.isCurrentPreEnv()) && (!TxUtils.isCurrentPreEnv() || TxUtils.isPreEnv(env))) {
                        try {
                            Map serviceMap = StringUtils.isEmpty(txMessage.getExtra()) ? null : TxUtils.parseExtra(txMessage.getExtra()).getSc();
                            ServiceChainContext.setInvocationServiceChainContext(serviceMap);
                            if (txMessage.getCompressed() != null && txMessage.getCompressed() == 1) {
                                txMessage.setMsgBody(CompressUtil.decompressString(txMessage.getMsgBody()));
                            }

                          //发送消息后删除表里的消息
                            this.doSendMsg(txMessage);
                        } catch (Throwable t) {
                            logger.error("Failed to send msg after scanning db.", t);
                        } finally {
                            ServiceChainContext.removeServiceChainContext();
                        }
                    }
                }
            }

            return txMessageList.size();
        }
    }
```

> 双写模版代码
```java

@Slf4j
@Component
public class GuideCommonDoubleTemplate {

    @Resource
    private CommonDbTransferWhiteComponent commonDbTransferWhiteComponent;//配置（配置白名单/黑名单/灰流比例）

    private static final ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 50, 1, TimeUnit.SECONDS, new ArrayBlockingQueue<>(1024), new ThreadPoolExecutor.DiscardPolicy());//NOSONAR

    public <T> T executeWrite(Long bzId, String method, Callable<T> oldWrite, Callable<T> newWrite) {
        if (guideCommonDbTransferWhiteComponent.readOld(bzId)) {//根据配置决定是否读取老数据
            T result = oldWrite.call();
            if (!commonDbTransferWhiteComponent.doubleWrite()) {
                return result;
            }
            try {
                newWrite.call();
            } catch (Exception e) {
                log.warn("表双写异常 method={}, 写新表异常, bzId={}", method, bzId, e);
            }
            return result;
        }
        T call = newWrite.call();
        if (!commonDbTransferWhiteComponent.doubleWrite()) {
            return call;
        }
        try {
            oldWrite.call();
        } catch (Exception e) {
            log.warn("表双写异常 method={}, 写旧表异常, bzId={}", method, bzId, e);
        }
        return call;
    }

    public <T> T executeRead(Long bzId, String method, Callable<T> oldRead, Callable<T> newRead) {
        if (guideCommonDbTransferWhiteComponent.readOld(bzId)) {
            T result = oldRead.call();
            // 读流量对账(这里旁路校验)
            threadPoolExecutor.execute(new FrameworkRunnable(() -> {
                boolean readCompare = commonDbTransferWhiteComponent.readCompare(bzId);
                if (!readCompare) {
                    return;
                }
                T newResult = newRead.call();
                compareListResult(bzId, method, newResult == null ? null : Arrays.asList(newResult), result == null ? null : Arrays.asList(result));
            }));
            return result;
        }
        return newRead.call();
    }

    public <T> List<T> executeListRead(Long bzId, String method, Callable<List<T>> oldRead, Callable<List<T>> newRead) {
        if (commonDbTransferWhiteComponent.readOld(bzId)) {
            List<T> result = oldRead.call();
            // 读流量对账
            threadPoolExecutor.execute(new FrameworkRunnable(() -> {
                boolean readCompare = commonDbTransferWhiteComponent.readCompare(kdtId);
                if (!readCompare) {
                    return;
                }
                List<T> newResult = newRead.call();
                compareListResult(bzId, method, newResult, result);
            }));
            return result;
        }
        return newRead.call();
    }

    private <T> void compareListResult(Long bzId, String method, List<T> newResult, List<T> result) {
        if (CollectionUtils.isEmpty(result) && CollectionUtils.isEmpty(newResult)) {
            return;
        }
        boolean equals = false;
        if (CollectionUtils.isEmpty(result) || CollectionUtils.isEmpty(newResult)) {
            log.info("业务表迁移查询对比 其中一个结果为空集合");
        } else if (!Objects.equals(newResult.size(), result.size())) {
            log.info("业务表迁移查询对比 size不一致, newSize={}, oldSize={}", newResult.size(), result.size());
        } else {
            equals = isEquals(newResult, result);
        }
        if (!equals) {
            String template = "业务表迁移查询对比 新老表数据异常, bzId:%s, method:%s, 查询对账不一致, old=%s, new=%s";
            String content = String.format(template, bzId, method, JSON.toJSONString(result), JSON.toJSONString(newResult));
            log.warn(content);
        }
    }

    public static <T> boolean isEquals(List<T> newResult, List<T> result) {
        boolean equals = false;
        sortById(newResult);
        sortById(result);
        for (int i = 0; i < newResult.size(); i++) {
            equals = isObjectsEqual(newResult.get(i), result.get(i));
            if (!equals) {
                break;
            }
        }
        return equals;
    }

    /**
     * sortById
     *
     * @param list list
     * @param <T>
     */
    public static <T> void sortById(List<T> list) {
        if (CollectionUtils.isEmpty(list) || list.size() <= 1) {
            return;
        }
        list.sort(Comparator.comparing(t -> {
            try {
                Method getIdMethod = t.getClass().getMethod("getId");
                return (Long) getIdMethod.invoke(t);
            } catch (Exception e) {//NOSONAR
                log.warn("业务表迁移, 实时读对账异常, Failed to invoke getId on", e);
            }
            return null;
        }));
    }

    public static boolean isObjectsEqual(Object obj1, Object obj2) {
        if (obj1 == obj2) {
            return true;
        }
        if (obj1 == null || obj2 == null) {
            log.info("比较对象，其中一个对象为null, obj1={}, obj2={}", JSON.toJSONString(obj1), JSON.toJSONString(obj2));
            return false;
        }
        if (obj1.getClass() != obj2.getClass()) {
            log.info("两个对象类型不匹配, obj1={}, obj2={}", obj1.getClass().getName(), obj2.getClass().getName());
            return false;
        }

        Class<?> clazz = obj1.getClass();
        Field[] fields = FieldUtils.getAllFields(clazz);
        for (Field field : fields) {
            if (StringUtils.equals("updatedAt", field.getName())) {
                continue;
            }
            if (StringUtils.equals("createdAt", field.getName())) {
                continue;
            }
            if (!field.isAccessible()) {//NOSONAR
                field.setAccessible(true);//NOSONAR
            }
            try {
                Object value1 = field.get(obj1);
                Object value2 = field.get(obj2);
                if (!Objects.equals(value1, value2)) {
                    log.info("业务表迁移查询对比 属性不一致 {} - obj1={}, obj2={}", field.getName(), JSON.toJSONString(value1),
                            JSON.toJSONString(value2));
                    return false;
                }
            } catch (IllegalAccessException e) {
                log.error("业务表迁移查询对比 无法访问字段: {}", field.getName(), e);
                return false;
            }
        }
        return true;
    }

    interface Callable<T> {
        T call();
    }
}

```
> 灰度/白名单/黑名单 配置类
```java
@Slf4j
@Component
public class WhiteConfig {

    @Resource
    private ShopCenterClient shopCenterClient;

    private final static String WHITE_LIST_NAMESPACE = "white_list";

    private static final Map<String, WhiteConfig> WHITE_CONFIG_MAP = Maps.newHashMap();

    @PostConstruct
    @SuppressWarnings({"pmd:UnusedPrivateMethod"})
    private void init() {
        Config config = ConfigService.getConfig(WHITE_LIST_NAMESPACE);
        Set<String> propertyNames = config.getPropertyNames();
        if (CollectionUtils.isEmpty(propertyNames)) {
            return;
        }
        configWhiteConfigMap(config, propertyNames);
        addChangeListener(config);
        log.info("白名单服务:初始化完成,whiteConfigMap={}", JSON.toJSONString(WHITE_CONFIG_MAP));
    }

    private synchronized void configWhiteConfigMap(Config config, Set<String> propertyNames) {
        for (String propertyName : propertyNames) {
            String property = config.getProperty(propertyName, "");
            WhiteConfig whiteListBean = WhiteConfig.buildWhiteListBean(propertyName, property);
            log.info("白名单服务:whiteListKey={},config={},whiteListBean={}", propertyName, property, JSONObject.toJSONString(whiteListBean));
            WHITE_CONFIG_MAP.put(propertyName, whiteListBean);
        }
    }

    private void addChangeListener(Config config) {
        config.addChangeListener(changeEvent -> {
            log.info("白名单服务:监听到白名单变化changEvent={}", changeEvent.getNamespace());
            String namespace = changeEvent.getNamespace();
            if (StringUtils.equals(namespace, WHITE_LIST_NAMESPACE)) {
                Set<String> changedKeys = changeEvent.changedKeys();
                log.info("白名单服务:监听到白名单变化keys={}", JSON.toJSONString(changedKeys));
                if (CollectionUtils.isEmpty(changedKeys)) {
                    return;
                }
                configWhiteConfigMap(config, changedKeys);
            }
        });
    }

    public boolean inWhiteList(String key, Long value) {
        WhiteConfig whiteConfig = WHITE_CONFIG_MAP.get(key);
        if (whiteConfig == null) {
            return false;
        }

        Long finalValue = value;

        return whiteConfig.inWhiteList(finalValue);
    }

    public boolean inWhiteList(String key, Long value, boolean isRootKdtId) {
        WhiteConfig whiteConfig = WHITE_CONFIG_MAP.get(key);
        if (whiteConfig == null) {
            return false;
        }
        // 如果没有传value值，在切流100%的情况下返回true，否则返回false
        if (value == null || value <= 0) {
            return whiteConfig.getRate() != null && whiteConfig.getRate() >= 100L;
        }
        // 连锁模式，如果传的value不是总店的id，则查询总部的id
        if (whiteConfig.isSupportChain() && !isRootKdtId) {
            value = MoreObjects.firstNonNull(getRootKdtId(value), value);
        }

        return whiteConfig.inWhiteList(value);
    }

    private Long getRootKdtId(Long value) {
        return shopCenterClient.getChainRootKdtIdThrow(value);
    }

    public boolean inWhiteList(String key, List<Long> values) {
        if (CollectionUtils.isEmpty(values)) {
            return false;
        }
        for (Long value : values) {
            if (inWhiteList(key, value)) {
                return true;
            }
        }
        return false;
    }


    @Slf4j
    @Data
    static class WhiteConfig {

        /**
         * 白名单Key
         */
        private String key;

        /**
         * 比率
         */
        private Long rate = 0L;

        /**
         * 最大比率
         */
        private static final Long MAX_RATE = 100L;

        /**
         * 是否支持连锁
         */
        private Boolean supportChain;

        /**
         * 白名单
         */
        private Set<Long> whiteList = Sets.newHashSet();

        /**
         * 黑名单
         */
        private Set<Long> blackList = Sets.newHashSet();


        static WhiteConfig buildWhiteListBean(String key, String config) {
            WhiteConfig whiteConfig = new WhiteConfig();
            whiteConfig.setKey(key);
            config = StringUtils.trim(config);
            if (StringUtils.isEmpty(config)) {
                return whiteConfig;
            }
            String[] split = config.split("\n");
            if (split.length == 0) {
                return whiteConfig;
            }

            String first = split[0];
            first = StringUtils.trim(first);
            if (first != null && first.contains("%")) {
                setRate(whiteConfig, first);
            }

            Set<Long> whiteList = whiteConfig.getWhiteList();
            Set<Long> blackList = whiteConfig.getBlackList();
            for (String m : split) {
                if (m.contains("%")) {
                    log.info("当前行为百分数({})，无法解析到黑白名单列表中，跳过", m);
                    continue;
                }
                if (StringUtils.isBlank(m)) {
                    continue;
                }
                try {
                    long item = Long.parseLong(m.trim());
                    if (item >= 0) {
                        whiteList.add(item);
                    } else {
                        blackList.add(-item);
                    }
                } catch (Exception e) {
                    log.error("白名单服务:解析白名单元素失败,config={},can't parse to long value,e={}", m, e);
                }
            }
            return whiteConfig;
        }

        private static void setRate(WhiteConfig whiteConfig, String first) {
            try {
                first = first.replace("%", "");
                if (StringUtils.isNotBlank(first)) {
                    whiteConfig.setRate(Long.valueOf(first));
                }
            } catch (Exception e) {
                log.error("白名单服务:解析百分比异常,first={},e={}", first, e);
            }
        }

        boolean inWhiteList(Long value) {
            try {
                if (value == null) {
                    return false;
                }
                //黑名单
                if (blackList.contains(value)) {
                    return false;
                }
                //白名单
                if (whiteList.contains(value)) {
                    return true;
                }
                //百分比
                long mod = value % MAX_RATE;
                return mod < rate;
            } catch (Exception e) {
                log.error("判断是否在白名单内异常,key={},value={},e={}", key, value, e);
                return false;
            }

        }

    }
}

```
