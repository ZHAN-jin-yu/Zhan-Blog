读美团技术文章《DynamicTp》
[文章来源](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)
- 64位操作系统Java一个线程栈需要占用1MB内存（-Xss可以修改）
- 一个Thead对象需要约200-300KB
  - 线程ID、线程状态、优先级等原数据
> 线程过多会带来创建/销毁/上下文切换的开销，线程过少会导致任务执行变慢 <br>
> **池化思想** 复用线程，可以降低创建/销毁开销，当任务到来，无需等待线程创建即可立即执行
>

## JUC
juc包主要包括：
- 原子类（AtomicXXX）
- 锁类（XXXLock）
- 线程同步类（AQS、CountDownLatch、CyclicBarrier、Semaphore）
- **任务执行器类**（Executor体系类，包括今天的主角ThreadPoolExecutor）
- 并发集合类（ConcurrentXXX、CopyOnWriteXXX）相关集合类
- 阻塞队列类（BlockingQueue继承体系类）
- Future相关类
> 注意：synchronize、voltile、Thread类等不属于JUC范畴

## 线程池原理
怎么做到线程复用？
核心点：只要**线程的的run方法不结束**，那这个线程就不会结束
![](/minio/weblog/ee02c9b0ff3847088d03d00835d26def.png)
> 从这个图可以看到，这里主要采用**生产者-消费者**模型：
> 当提交任务时，他底层会对你的runnable进行包装成一个task(增强),然后给worker
>
> 通过**while循环的方式不断从队列获取任务，从而让run方法不结束**。<br>
> 注意：如果是非核心线程，就是 **取任务的时候加一个超时时间** poll(timeOut);
> ```java
> try {
>  while (task != null || (task = getTask()) != null) {
>    //执行任务
>  }
> } finally {
>  processWorkerExit(w, completedAbruptly);//获取不到任务时，主动回收自己
> }
> ```
![](/minio/weblog/2fa33e90ad444261a7f8e30af40cb710.png)
```java
 private final class Worker extends AbstractQueuedSynchronizer implements Runnable{
    final Thread thread;//Worker持有的线程
    Runnable firstTask;//初始化的任务，可以为null（非核心线程）
 }
```
可以看到worker还**继承了AQS抽象类**
> 使用AQS来实现**独占锁**这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现**不可重入的特性**去反应线程现在的执行状态。<br>
> 当**任务执行前，会先占用这把锁**，执行完成后释放
> ![](/minio/weblog/ae4516ae8f564852bd43d17c7971715e.png)
> 当调用shutdown()方法去**关闭线程池的时候**，他会尝试去获取锁，如果获取失败，说明当前任务还没有结束，不能回收当前线程
## 动态化线程池
> - 代码中创建了一个ThreadPoolExecutor，但是不知道那几个核心参数设置多少比较合适
> - 凭经验设置参数值，上线后发现需要调整，改代码重启服务，非常麻烦
所以可以利用jdk对ThreadPoolExecutor提供的API去动态的修改线程池参数
```java
public void setCorePoolSize(int corePoolSize);
public void setMaximumPoolSize(int maximumPoolSize);
public void setKeepAliveTime(long time, TimeUnit unit);
public void setThreadFactory(ThreadFactory threadFactory);
public void setRejectedExecutionHandler(RejectedExecutionHandler handler);
```
**注意**：LinkedBlockingQueue/ArrayBlockingQueue的capacity是使用**final修饰**的，不能修改其容量，如果想要修改，可以使用ResizableCapacityBlockingQueue
### 怎么监控？
ThreadPoolExecutor还提供一系列Getter方法，可以观察到当前线程池的状态
![](/minio/weblog/11a350bb4eed4ac99efed08d7ce3ffc3.png)
> 我们可以把这东西展示在平台侧，让开发人员可以动态调整
>
动态化线程池提供如下功能：
- 动态调参：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效。 
- 任务监控：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95/99线等。 
- 负载告警：线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人。
- 操作监控：创建/修改和删除线程池都会通知到应用的开发负责人。 
- 操作日志：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。 
- 权限校验：只有应用开发负责人才能够修改应用的线程池参数。

## 使用
- maven依赖
```xml
<!--apollo应用用接入用此依赖 -->
<dependency>
   <groupId>io.github.lyh200</groupId>
   <artifactId>dynamic-tp-spring-boot-starter-apollo</artifactId>
   <version>1.0.1</version>
</dependency>
<!--nacos应用用接入用此依赖 -->
<dependency>
    <groupId>io.github.lyh200</groupId>
    <artifactId>dynamic-tp-spring-cloud-starter-nacos</artifactId>
    <version>1.0.1</version>
</dependency>
<!--springBoot-nacos应用用接入用此依赖 -->
<dependency>
    <groupId>io.github.lyh200</groupId>
    <artifactId>dynamic-tp-spring-boot-starter-nacos</artifactId>
    <version>1.0.1</version>
</dependency>
```
- 配置项
```yml
spring:
  dynamic:
    tp:
      enabled: true
      enabledBanner: true        # 是否开启banner打印，默认true
      enabledCollect: false      # 是否开启监控指标采集，默认false
      collectorType: logging     # 监控数据采集器类型（JsonLog | MicroMeter），默认logging
      logPath: /home/logs        # 监控日志数据路径，默认${user.home}/logs
      monitorInterval: 5         # 监控时间间隔（报警判断、指标采集），默认5s
      nacos:                     # nacos配置，不配置有默认值（规则name-dev.yml这样）
        dataId: dynamic-tp-demo-dev.yml
        group: DEFAULT_GROUP
      apollo:                    # apollo配置，不配置默认拿apollo配置第一个namespace
        namespace: dynamic-tp-demo-dev.yml
      configType: yml            # 配置文件类型
      platforms:                 # 通知报警平台配置
        - platform: wechat
          urlKey: 3a7500-1287-4bd-a798-c5c3d8b69c  # 替换
          receivers: test1,test2                   # 接受人企微名称
        - platform: ding
          urlKey: f80dad441fcd655438f4a08dcd6a     # 替换
          secret: SECb5441fa6f375d5b9d21           # 替换，非sign模式可以没有此值
          receivers: 15810119805                   # 钉钉账号手机号    
      tomcatTp:                                    # tomcat web server线程池配置
          minSpare: 100
          max: 400      
      jettyTp:                                     # jetty web server线程池配置
          min: 100
          max: 400     
      undertowTp:                                  # undertow web server线程池配置
          ioThreads: 100
          workerThreads: 400      
      executors:                                   # 动态线程池配置
        - threadPoolName: dynamic-tp-test-1
          corePoolSize: 6
          maximumPoolSize: 8
          queueCapacity: 200
          queueType: VariableLinkedBlockingQueue   # 任务队列，查看源码QueueTypeEnum枚举类
          rejectedHandlerType: CallerRunsPolicy    # 拒绝策略，查看RejectedTypeEnum枚举类
          keepAliveTime: 50
          allowCoreThreadTimeOut: false
          threadNamePrefix: test           # 线程名前缀
          notifyItems:                     # 报警项，不配置自动会配置（变更通知、容量报警、活性报警、拒绝报警）
            - type: capacity               # 报警项类型，查看源码 NotifyTypeEnum枚举类
              enabled: true
              threshold: 80                # 报警阈值
              platforms: [ding,wechat]     # 可选配置，不配置默认拿上层platforms配置的所以平台
              interval: 120                # 报警间隔（单位：s）
            - type: change
              enabled: true
            - type: liveness
              enabled: true
              threshold: 80
            - type: reject
              enabled: true
              threshold: 1
```
- 使用
```java
@Configuration
public class DtpConfig {
 
   @Bean
   public DtpExecutor demo1Executor() {
       return DtpCreator.createDynamicFast("demo1-executor");
  }
 
   @Bean
   public ThreadPoolExecutor demo2Executor() {
       return ThreadPoolBuilder.newBuilder()
              .threadPoolName("demo2-executor")
              .corePoolSize(8)
              .maximumPoolSize(16)
              .keepAliveTime(50)
              .allowCoreThreadTimeOut(true)
              .workQueue(QueueTypeEnum.SYNCHRONOUS_QUEUE.getName(), null, false)
              .rejectedExecutionHandler(RejectedTypeEnum.CALLER_RUNS_POLICY.getName())
              .buildDynamic();
  }

  public static void main(String[] args) {
       DtpExecutor dtpExecutor = DtpRegistry.getExecutor("dynamic-tp-test-1");
       dtpExecutor.execute(() -> System.out.println("test"));
  }
}

```
## Dtp架构设计

![](/minio/weblog/86a5ebe05a8946cb98e5f9fb4da654c7.png)
主要分**四大模块**
- 配置变更监听模块：
  
   - 监听特定配置中心的指定配置文件（默认实现Nacos、Apollo）,可通过内部提供的SPI接口扩展其他实现
   - 解析配置文件内容，内置实现yml、properties配置文件的解析，可通过内部提供的SPI接口扩展其他实现
   - 通知线程池管理模块实现刷新


- 线程池管理模块：

  - 服务启动时从配置中心拉取配置信息，生成线程池实例注册到内部线程池注册中心中

  - 监听模块监听到配置变更时，将变更信息传递给管理模块，实现线程池参数的刷新

  - 代码中通过getExecutor()方法根据线程池名称来获取线程池对象实例

- 监控模块：

  实现监控指标采集以及输出，默认提供以下三种方式，也可通过内部提供的SPI接口扩展其他实现

  -  默认实现Json log输出到磁盘

  -  MicroMeter采集，引入MicroMeter相关依赖

  -  暴露Endpoint端点，可通过http方式访问

- 通知告警模块：

  对接办公平台，实现通告告警功能，默认实现钉钉、企微，可通过内部提供的SPI接口扩展其他实现，通知告警类型如下

  -  线程池参数变更通知

  -  阻塞队列容量达到设置阈值告警

  -  线程池活性达到设置阈值告警( activeCount/maximumPoolSize)

  -  触发拒绝策略告警
 
